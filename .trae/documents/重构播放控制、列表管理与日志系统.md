## 风险修正与架构微调

### 事件驱动纯化
- 交互层仅下指令与应答：按钮使用 `deferUpdate`，命令使用 `reply(ephemeral)`。
- UI 刷新完全依赖 `PlayerControl` 的 `player_state_changed` 事件 → `InterfaceUpdater` 编辑/发送消息。

### 命令与按钮统一入口
- `/pause`、`/resume`、`/skip`、`/prev`、`/stop` 与按钮一致直连 `PlayerControl`。
- `/play` 采用 `PlaylistManager.add + PlayerControl.play`，不手动更新 UI。

### Interaction Token 与竞态
- `InterfaceUpdater` 维护 `channelId/messageId`，优先编辑，失败发送新消息并更新 `messageId`。
- 序号机制保证最新状态覆盖旧状态，避免并发回跳。

### 日志规范
- 使用 `logger_service` 输出 `[timestamp][LEVEL][message][context]`。
- `ERROR` 独立按日文件，`INFO/WARN` 控制台与应用日志。

### 已实施变更摘要
- 交互迁移：`src/bot/events/interactionCreate.js` 控制按钮改为调用 `PlayerControl` 并 `deferUpdate`。
- 命令迁移：`pause/resume/skip/prev/stop/play/hachimi` 统一事件驱动；移除手动 `notifyState`。
- 日志迁移：核心文件替换为 `logger_service`。
- 测试：新增单元测试全部通过。

### 下一步
- 按步骤继续清理废弃接口并在 `docs/architecture.md` 与 `docs/structure.md` 同步架构说明。
- Interaction Token 过期：不再依赖旧 `interaction.editReply`。新增 `src/ui/interface_updater.js` 单例维护每个 Guild 的 `textChannelId` 与 `lastNowPlayingMessageId`，通过 `channel.messages.edit(...)` 优先更新；若失败或消息不存在则 `channel.send(...)` 并更新 `lastNowPlayingMessageId`。
- 全局唯一订阅：在 `src/index.js` 或 `src/bot/client.js` 启动时对 `PlayerControl` 与 `PlaylistManager` 进行一次性订阅，避免在 `interactionCreate` 中重复注册导致内存泄漏。
- 并发竞态：`interface_updater` 内实现每 Guild 的更新互斥/顺序保证（简单 Mutex + 更新序号，始终以最新状态覆盖旧状态）。
- 日志级别策略：保留 `INFO/WARN`。`ERROR` 写入 `error-YYYY-MM-DD.log`；`INFO/WARN` 输出到控制台并可选写入 `app-YYYY-MM-DD.log`（便于排障）。

## 模块与接口
- `src/player_control.js`
  - `initialize(audioManager)`：注入 `AudioManager`；内部创建 `EventEmitter`。
  - `onStateChanged(handler)`：订阅播放状态事件。
  - `play/pause/next/prev(guildId)`：驱动 `AudioPlayer` 状态；成功后 `emit('player_state_changed', { guildId, state, track })`；异常走 `logger_service.error`。
- `src/playlist_manager.js`
  - `initialize(audioManager)`；内部创建 `EventEmitter`。
  - `onMessage(handler)`：订阅文本提示事件。
  - `add(guildId, videoData, requestedBy)`：调用 `AudioPlayer.addToQueue`；`emit('playlist_message', { guildId, text })`。
  - `remove(guildId, index)`：调用 `AudioPlayer.removeFromQueue`；`emit('playlist_message', { guildId, text })`。
- `src/logger_service.js`
  - `error(message, context)`、`fatal(message, context)`；行格式 `[YYYY-MM-DD HH:mm:ss][LEVEL][message][contextJSON]`。
  - 文件：`logs/error-YYYY-MM-DD.log`；可选 `logs/app-YYYY-MM-DD.log`；控制台开启 `info/warn`。
- `src/ui/interface_updater.js`（新增单例）
  - `bind(playerControl)`：一次性订阅 `player_state_changed`，调用 `handleUpdate(guildId, state)`。
  - `setPlaybackContext(guildId, textChannelId, messageId?)`：供命令在首次播放或迁移消息时设置上下文。
  - `handleUpdate(guildId, state)`：
    - 查找 `textChannelId/lastMessageId`；优先 `messages.edit(lastMessageId, ...)`；失败则 `send(...)` 并更新 `lastMessageId`。
    - 以 Mutex/序号保证最新状态覆盖；异常写 `logger_service.error`。

## 代码改造点
- `src/bot/client.js`（或 `src/index.js`）
  - 初始化单例：`PlayerControl.initialize(AudioManager)`、`PlaylistManager.initialize(AudioManager)`；`InterfaceUpdater.bind(PlayerControl)`。
  - 在命令首次触发播放时调用 `InterfaceUpdater.setPlaybackContext(guildId, interaction.channelId, optionalMessageId)`。
- `src/bot/events/interactionCreate.js`
  - 移除对全局事件的订阅；改为：
    - 控制类命令：调用 `PlayerControl.*`，其事件触发后由 `interface_updater` 统一更新 UI。
    - 列表类命令：调用 `PlaylistManager.*`，仅发送 `ephemeral` 文本（订阅者或命令直接读取返回 text）。
- `src/audio/manager.js`
  - 保持 Guild→Player 获取与纯状态返回；不负责 UI；必要处改用 `logger_service`。
- 现有命令迁移：
  - `pause/resume/skip/prev/stop` → `PlayerControl`；命令中记录播放上下文（`setPlaybackContext`）。
  - `play/search/hachimi/queue/remove` → `PlaylistManager`；只输出文本提示；如需开始播放，调用 `PlayerControl.play()` 以走专用通道。

## 状态与通知规范
- 专用通道：所有播放状态变更仅通过 `player_state_changed` 通知 UI；UI 不直接读取 `AudioManager`。
- 轻量总线：所有列表改动仅通过文本消息通知；不更新 UI 组件。

## 日志实现细节
- `ERROR` 独立文件每日分割；`INFO/WARN` 控制台 + 可选 app 日志。
- 覆盖：入口异常、播放控制异常、队列异常、UI 更新失败（如编辑失败/发送失败）。

## 测试计划
- `tests/unit/player_control.test.js`：验证 `play/pause/next/prev` 触发一次事件，负载正确；异常路径写入 `logger_service`。
- `tests/unit/playlist_manager.test.js`：验证 `add/remove` 仅发文本事件；非法索引记录错误。
- `tests/unit/interface_updater.test.js`：
  - 模拟 `lastMessageId` 编辑失败回退到 `send(...)` 并更新 `lastMessageId`。
  - 快速连续状态变更时，最终 UI 与最后一次状态一致（验证 Mutex/序号）。
- `tests/unit/logger_service.test.js`：格式匹配与按日期写入。

## 迁移步骤
1. 新增 `player_control.js`、`playlist_manager.js`、`logger_service.js`、`ui/interface_updater.js`。
2. 在启动流程（`index.js` 或 `bot/client.js`）完成一次性初始化与绑定。
3. 命令文件重构为调用新模块接口；在首次播放时设置 UI 上下文。
4. 替换关键路径日志入口为 `logger_service`。
5. 添加并运行单测；修复发现问题。

如以上修正与微调可接受，我将按该方案实施并提交改造与测试。
